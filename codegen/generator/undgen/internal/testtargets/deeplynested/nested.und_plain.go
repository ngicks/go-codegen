// Code generated by github.com/ngicks/go-codegen/codegen DO NOT EDIT.
// to regenerate the code, refer to help by invoking
// go run github.com/ngicks/go-codegen/codegen undgen plain --help

package deeplynested

import (
	"github.com/ngicks/go-codegen/codegen/generator/undgen/internal/testtargets/implementor"
	"github.com/ngicks/und"
	"github.com/ngicks/und/option"
)

//codegen:generated
type DeeplyNestedImplementorPlain struct {
	A []map[string][5]implementor.ImplementorPlain[string] `und:"required"`
	B [][][]map[int]implementor.ImplementorPlain[string]
	C []map[string][5]*implementor.ImplementorPlain[string] `und:"required"`
	D [][][]map[int]*implementor.ImplementorPlain[string]
}

//codegen:generated
func (v DeeplyNestedImplementor) UndPlain() DeeplyNestedImplementorPlain {
	return DeeplyNestedImplementorPlain{
		A: (func(v []map[string][5]und.Und[implementor.Implementor[string]]) []map[string][5]implementor.ImplementorPlain[string] {
			out := make([]map[string][5]implementor.ImplementorPlain[string], len(v))

			inner := out
			for k, v := range v {
				outer := &inner
				inner := make(map[string][5]implementor.ImplementorPlain[string], len(v))
				for k, v := range v {
					outer := &inner
					inner := [5]implementor.ImplementorPlain[string]{}
					for k, v := range v {
						inner[k] = und.Map(
							v,
							func(v implementor.Implementor[string]) implementor.ImplementorPlain[string] {
								vv := v.UndPlain()
								return vv
							},
						).Value()
					}
					(*outer)[k] = inner
				}
				(*outer)[k] = inner
			}

			return out
		})(v.A),
		B: (func(v [][][]map[int]implementor.Implementor[string]) [][][]map[int]implementor.ImplementorPlain[string] {
			out := make([][][]map[int]implementor.ImplementorPlain[string], len(v))

			inner := out
			for k, v := range v {
				outer := &inner
				inner := make([][]map[int]implementor.ImplementorPlain[string], len(v))
				for k, v := range v {
					outer := &inner
					inner := make([]map[int]implementor.ImplementorPlain[string], len(v))
					for k, v := range v {
						outer := &inner
						inner := make(map[int]implementor.ImplementorPlain[string], len(v))
						for k, v := range v {
							inner[k] = v.UndPlain()
						}
						(*outer)[k] = inner
					}
					(*outer)[k] = inner
				}
				(*outer)[k] = inner
			}

			return out
		})(v.B),
		C: (func(v []map[string][5]und.Und[*implementor.Implementor[string]]) []map[string][5]*implementor.ImplementorPlain[string] {
			out := make([]map[string][5]*implementor.ImplementorPlain[string], len(v))

			inner := out
			for k, v := range v {
				outer := &inner
				inner := make(map[string][5]*implementor.ImplementorPlain[string], len(v))
				for k, v := range v {
					outer := &inner
					inner := [5]*implementor.ImplementorPlain[string]{}
					for k, v := range v {
						inner[k] = und.Map(
							v,
							func(v *implementor.Implementor[string]) *implementor.ImplementorPlain[string] {
								if v == nil {
									return nil
								}
								vv := v.UndPlain()
								return &vv
							},
						).Value()
					}
					(*outer)[k] = inner
				}
				(*outer)[k] = inner
			}

			return out
		})(v.C),
		D: (func(v [][][]map[int]*implementor.Implementor[string]) [][][]map[int]*implementor.ImplementorPlain[string] {
			out := make([][][]map[int]*implementor.ImplementorPlain[string], len(v))

			inner := out
			for k, v := range v {
				outer := &inner
				inner := make([][]map[int]*implementor.ImplementorPlain[string], len(v))
				for k, v := range v {
					outer := &inner
					inner := make([]map[int]*implementor.ImplementorPlain[string], len(v))
					for k, v := range v {
						outer := &inner
						inner := make(map[int]*implementor.ImplementorPlain[string], len(v))
						for k, v := range v {
							inner[k] = func(v *implementor.Implementor[string]) *implementor.ImplementorPlain[string] {
								if v == nil {
									return nil
								}
								vv := v.UndPlain()
								return &vv
							}(v)
						}
						(*outer)[k] = inner
					}
					(*outer)[k] = inner
				}
				(*outer)[k] = inner
			}

			return out
		})(v.D),
	}
}

//codegen:generated
func (v DeeplyNestedImplementorPlain) UndRaw() DeeplyNestedImplementor {
	return DeeplyNestedImplementor{
		A: (func(v []map[string][5]implementor.ImplementorPlain[string]) []map[string][5]und.Und[implementor.Implementor[string]] {
			out := make([]map[string][5]und.Und[implementor.Implementor[string]], len(v))

			inner := out
			for k, v := range v {
				outer := &inner
				inner := make(map[string][5]und.Und[implementor.Implementor[string]], len(v))
				for k, v := range v {
					outer := &inner
					inner := [5]und.Und[implementor.Implementor[string]]{}
					for k, v := range v {
						inner[k] = und.Map(
							und.Defined(v),
							func(v implementor.ImplementorPlain[string]) implementor.Implementor[string] {
								vv := v.UndRaw()
								return vv
							},
						)
					}
					(*outer)[k] = inner
				}
				(*outer)[k] = inner
			}

			return out
		})(v.A),
		B: (func(v [][][]map[int]implementor.ImplementorPlain[string]) [][][]map[int]implementor.Implementor[string] {
			out := make([][][]map[int]implementor.Implementor[string], len(v))

			inner := out
			for k, v := range v {
				outer := &inner
				inner := make([][]map[int]implementor.Implementor[string], len(v))
				for k, v := range v {
					outer := &inner
					inner := make([]map[int]implementor.Implementor[string], len(v))
					for k, v := range v {
						outer := &inner
						inner := make(map[int]implementor.Implementor[string], len(v))
						for k, v := range v {
							inner[k] = v.UndRaw()
						}
						(*outer)[k] = inner
					}
					(*outer)[k] = inner
				}
				(*outer)[k] = inner
			}

			return out
		})(v.B),
		C: (func(v []map[string][5]*implementor.ImplementorPlain[string]) []map[string][5]und.Und[*implementor.Implementor[string]] {
			out := make([]map[string][5]und.Und[*implementor.Implementor[string]], len(v))

			inner := out
			for k, v := range v {
				outer := &inner
				inner := make(map[string][5]und.Und[*implementor.Implementor[string]], len(v))
				for k, v := range v {
					outer := &inner
					inner := [5]und.Und[*implementor.Implementor[string]]{}
					for k, v := range v {
						inner[k] = und.Map(
							und.Defined(v),
							func(v *implementor.ImplementorPlain[string]) *implementor.Implementor[string] {
								if v == nil {
									return nil
								}
								vv := v.UndRaw()
								return &vv
							},
						)
					}
					(*outer)[k] = inner
				}
				(*outer)[k] = inner
			}

			return out
		})(v.C),
		D: (func(v [][][]map[int]*implementor.ImplementorPlain[string]) [][][]map[int]*implementor.Implementor[string] {
			out := make([][][]map[int]*implementor.Implementor[string], len(v))

			inner := out
			for k, v := range v {
				outer := &inner
				inner := make([][]map[int]*implementor.Implementor[string], len(v))
				for k, v := range v {
					outer := &inner
					inner := make([]map[int]*implementor.Implementor[string], len(v))
					for k, v := range v {
						outer := &inner
						inner := make(map[int]*implementor.Implementor[string], len(v))
						for k, v := range v {
							inner[k] = func(v *implementor.ImplementorPlain[string]) *implementor.Implementor[string] {
								if v == nil {
									return nil
								}
								vv := v.UndRaw()
								return &vv
							}(v)
						}
						(*outer)[k] = inner
					}
					(*outer)[k] = inner
				}
				(*outer)[k] = inner
			}

			return out
		})(v.D),
	}
}

//codegen:generated
type DependantPlain struct {
	Opt string `und:"required"`
}

//codegen:generated
func (v Dependant) UndPlain() DependantPlain {
	return DependantPlain{
		Opt: v.Opt.Value(),
	}
}

//codegen:generated
func (v DependantPlain) UndRaw() Dependant {
	return Dependant{
		Opt: option.Some(v.Opt),
	}
}

//codegen:generated
type DeeplyNestedDependantPlain struct {
	A []map[string][5]DependantPlain `und:"required"`
	B [][][]map[int]DependantPlain
	C []map[string][5]*DependantPlain `und:"required"`
	D [][][]map[int]*DependantPlain
}

//codegen:generated
func (v DeeplyNestedDependant) UndPlain() DeeplyNestedDependantPlain {
	return DeeplyNestedDependantPlain{
		A: (func(v []map[string][5]und.Und[Dependant]) []map[string][5]DependantPlain {
			out := make([]map[string][5]DependantPlain, len(v))

			inner := out
			for k, v := range v {
				outer := &inner
				inner := make(map[string][5]DependantPlain, len(v))
				for k, v := range v {
					outer := &inner
					inner := [5]DependantPlain{}
					for k, v := range v {
						inner[k] = und.Map(
							v,
							func(v Dependant) DependantPlain {
								vv := v.UndPlain()
								return vv
							},
						).Value()
					}
					(*outer)[k] = inner
				}
				(*outer)[k] = inner
			}

			return out
		})(v.A),
		B: (func(v [][][]map[int]Dependant) [][][]map[int]DependantPlain {
			out := make([][][]map[int]DependantPlain, len(v))

			inner := out
			for k, v := range v {
				outer := &inner
				inner := make([][]map[int]DependantPlain, len(v))
				for k, v := range v {
					outer := &inner
					inner := make([]map[int]DependantPlain, len(v))
					for k, v := range v {
						outer := &inner
						inner := make(map[int]DependantPlain, len(v))
						for k, v := range v {
							inner[k] = v.UndPlain()
						}
						(*outer)[k] = inner
					}
					(*outer)[k] = inner
				}
				(*outer)[k] = inner
			}

			return out
		})(v.B),
		C: (func(v []map[string][5]und.Und[*Dependant]) []map[string][5]*DependantPlain {
			out := make([]map[string][5]*DependantPlain, len(v))

			inner := out
			for k, v := range v {
				outer := &inner
				inner := make(map[string][5]*DependantPlain, len(v))
				for k, v := range v {
					outer := &inner
					inner := [5]*DependantPlain{}
					for k, v := range v {
						inner[k] = und.Map(
							v,
							func(v *Dependant) *DependantPlain {
								if v == nil {
									return nil
								}
								vv := v.UndPlain()
								return &vv
							},
						).Value()
					}
					(*outer)[k] = inner
				}
				(*outer)[k] = inner
			}

			return out
		})(v.C),
		D: (func(v [][][]map[int]*Dependant) [][][]map[int]*DependantPlain {
			out := make([][][]map[int]*DependantPlain, len(v))

			inner := out
			for k, v := range v {
				outer := &inner
				inner := make([][]map[int]*DependantPlain, len(v))
				for k, v := range v {
					outer := &inner
					inner := make([]map[int]*DependantPlain, len(v))
					for k, v := range v {
						outer := &inner
						inner := make(map[int]*DependantPlain, len(v))
						for k, v := range v {
							inner[k] = func(v *Dependant) *DependantPlain {
								if v == nil {
									return nil
								}
								vv := v.UndPlain()
								return &vv
							}(v)
						}
						(*outer)[k] = inner
					}
					(*outer)[k] = inner
				}
				(*outer)[k] = inner
			}

			return out
		})(v.D),
	}
}

//codegen:generated
func (v DeeplyNestedDependantPlain) UndRaw() DeeplyNestedDependant {
	return DeeplyNestedDependant{
		A: (func(v []map[string][5]DependantPlain) []map[string][5]und.Und[Dependant] {
			out := make([]map[string][5]und.Und[Dependant], len(v))

			inner := out
			for k, v := range v {
				outer := &inner
				inner := make(map[string][5]und.Und[Dependant], len(v))
				for k, v := range v {
					outer := &inner
					inner := [5]und.Und[Dependant]{}
					for k, v := range v {
						inner[k] = und.Map(
							und.Defined(v),
							func(v DependantPlain) Dependant {
								vv := v.UndRaw()
								return vv
							},
						)
					}
					(*outer)[k] = inner
				}
				(*outer)[k] = inner
			}

			return out
		})(v.A),
		B: (func(v [][][]map[int]DependantPlain) [][][]map[int]Dependant {
			out := make([][][]map[int]Dependant, len(v))

			inner := out
			for k, v := range v {
				outer := &inner
				inner := make([][]map[int]Dependant, len(v))
				for k, v := range v {
					outer := &inner
					inner := make([]map[int]Dependant, len(v))
					for k, v := range v {
						outer := &inner
						inner := make(map[int]Dependant, len(v))
						for k, v := range v {
							inner[k] = v.UndRaw()
						}
						(*outer)[k] = inner
					}
					(*outer)[k] = inner
				}
				(*outer)[k] = inner
			}

			return out
		})(v.B),
		C: (func(v []map[string][5]*DependantPlain) []map[string][5]und.Und[*Dependant] {
			out := make([]map[string][5]und.Und[*Dependant], len(v))

			inner := out
			for k, v := range v {
				outer := &inner
				inner := make(map[string][5]und.Und[*Dependant], len(v))
				for k, v := range v {
					outer := &inner
					inner := [5]und.Und[*Dependant]{}
					for k, v := range v {
						inner[k] = und.Map(
							und.Defined(v),
							func(v *DependantPlain) *Dependant {
								if v == nil {
									return nil
								}
								vv := v.UndRaw()
								return &vv
							},
						)
					}
					(*outer)[k] = inner
				}
				(*outer)[k] = inner
			}

			return out
		})(v.C),
		D: (func(v [][][]map[int]*DependantPlain) [][][]map[int]*Dependant {
			out := make([][][]map[int]*Dependant, len(v))

			inner := out
			for k, v := range v {
				outer := &inner
				inner := make([][]map[int]*Dependant, len(v))
				for k, v := range v {
					outer := &inner
					inner := make([]map[int]*Dependant, len(v))
					for k, v := range v {
						outer := &inner
						inner := make(map[int]*Dependant, len(v))
						for k, v := range v {
							inner[k] = func(v *DependantPlain) *Dependant {
								if v == nil {
									return nil
								}
								vv := v.UndRaw()
								return &vv
							}(v)
						}
						(*outer)[k] = inner
					}
					(*outer)[k] = inner
				}
				(*outer)[k] = inner
			}

			return out
		})(v.D),
	}
}

//codegen:generated
type DeeplyNestedImplementorMapPlain []map[string][5]und.Und[implementor.ImplementorPlain[string]]

//codegen:generated
func (v DeeplyNestedImplementorMap) UndPlain() DeeplyNestedImplementorMapPlain {
	return (func(v []map[string][5]und.Und[implementor.Implementor[string]]) []map[string][5]und.Und[implementor.ImplementorPlain[string]] {
		out := make([]map[string][5]und.Und[implementor.ImplementorPlain[string]], len(v))

		inner := out
		for k, v := range v {
			outer := &inner
			inner := make(map[string][5]und.Und[implementor.ImplementorPlain[string]], len(v))
			for k, v := range v {
				outer := &inner
				inner := [5]und.Und[implementor.ImplementorPlain[string]]{}
				for k, v := range v {
					inner[k] = und.Map(
						v,
						func(v implementor.Implementor[string]) implementor.ImplementorPlain[string] {
							vv := v.UndPlain()
							return vv
						},
					)
				}
				(*outer)[k] = inner
			}
			(*outer)[k] = inner
		}

		return out
	})(v)
}

//codegen:generated
func (v DeeplyNestedImplementorMapPlain) UndRaw() DeeplyNestedImplementorMap {
	return (func(v []map[string][5]und.Und[implementor.ImplementorPlain[string]]) []map[string][5]und.Und[implementor.Implementor[string]] {
		out := make([]map[string][5]und.Und[implementor.Implementor[string]], len(v))

		inner := out
		for k, v := range v {
			outer := &inner
			inner := make(map[string][5]und.Und[implementor.Implementor[string]], len(v))
			for k, v := range v {
				outer := &inner
				inner := [5]und.Und[implementor.Implementor[string]]{}
				for k, v := range v {
					inner[k] = und.Map(
						v,
						func(v implementor.ImplementorPlain[string]) implementor.Implementor[string] {
							vv := v.UndRaw()
							return vv
						},
					)
				}
				(*outer)[k] = inner
			}
			(*outer)[k] = inner
		}

		return out
	})(v)
}

//codegen:generated
type DeeplyNestedDependantMapPlain []map[string][5]und.Und[DependantPlain]

//codegen:generated
func (v DeeplyNestedDependantMap) UndPlain() DeeplyNestedDependantMapPlain {
	return (func(v []map[string][5]und.Und[Dependant]) []map[string][5]und.Und[DependantPlain] {
		out := make([]map[string][5]und.Und[DependantPlain], len(v))

		inner := out
		for k, v := range v {
			outer := &inner
			inner := make(map[string][5]und.Und[DependantPlain], len(v))
			for k, v := range v {
				outer := &inner
				inner := [5]und.Und[DependantPlain]{}
				for k, v := range v {
					inner[k] = und.Map(
						v,
						func(v Dependant) DependantPlain {
							vv := v.UndPlain()
							return vv
						},
					)
				}
				(*outer)[k] = inner
			}
			(*outer)[k] = inner
		}

		return out
	})(v)
}

//codegen:generated
func (v DeeplyNestedDependantMapPlain) UndRaw() DeeplyNestedDependantMap {
	return (func(v []map[string][5]und.Und[DependantPlain]) []map[string][5]und.Und[Dependant] {
		out := make([]map[string][5]und.Und[Dependant], len(v))

		inner := out
		for k, v := range v {
			outer := &inner
			inner := make(map[string][5]und.Und[Dependant], len(v))
			for k, v := range v {
				outer := &inner
				inner := [5]und.Und[Dependant]{}
				for k, v := range v {
					inner[k] = und.Map(
						v,
						func(v DependantPlain) Dependant {
							vv := v.UndRaw()
							return vv
						},
					)
				}
				(*outer)[k] = inner
			}
			(*outer)[k] = inner
		}

		return out
	})(v)
}
