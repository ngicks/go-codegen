// Code generated by github.com/ngicks/go-codegen/codegen DO NOT EDIT.
// to regenerate the code, refer to help by invoking
// go run github.com/ngicks/go-codegen/codegen undgen plain --help
package typeparam

import (
	"github.com/ngicks/und"
	"github.com/ngicks/und/conversion"
	"github.com/ngicks/und/elastic"
	"github.com/ngicks/und/option"
)

//codegen:generated
type WithTypeParamPlain[T any] struct {
	Foo string
	Bar T
	Baz T               `json:",omitzero" und:"required"`
	Qux map[string][2]T `json:"qux" und:"len==2,values:nonnull"`
}

//codegen:generated
func (v WithTypeParam[T]) UndPlain() WithTypeParamPlain[T] {
	return WithTypeParamPlain[T]{
		Foo: v.Foo,
		Bar: v.Bar,
		Baz: v.Baz.Value(),
		Qux: (func(v map[string]elastic.Elastic[T]) map[string][2]T {
			out := make(map[string][2]T, len(v))

			inner := out
			for k, v := range v {
				inner[k] = und.Map(
					und.Map(
						conversion.UnwrapElastic(v),
						func(o []option.Option[T]) (out [2]option.Option[T]) {
							copy(out[:], o)
							return out
						},
					),
					func(s [2]option.Option[T]) (r [2]T) {
						for i := 0; i < 2; i++ {
							r[i] = s[i].Value()
						}
						return
					},
				).Value()
			}

			return out
		})(v.Qux),
	}
}

//codegen:generated
func (v WithTypeParamPlain[T]) UndRaw() WithTypeParam[T] {
	return WithTypeParam[T]{
		Foo: v.Foo,
		Bar: v.Bar,
		Baz: option.Some(v.Baz),
		Qux: (func(v map[string][2]T) map[string]elastic.Elastic[T] {
			out := make(map[string]elastic.Elastic[T], len(v))

			inner := out
			for k, v := range v {
				inner[k] = elastic.FromUnd(und.Map(
					und.Map(
						und.Defined(v),
						func(s [2]T) (out [2]option.Option[T]) {
							for i := 0; i < 2; i++ {
								out[i] = option.Some(s[i])
							}
							return
						},
					),
					func(s [2]option.Option[T]) []option.Option[T] {
						return s[:]
					},
				))
			}

			return out
		})(v.Qux),
	}
}
