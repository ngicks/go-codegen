package main

import (
	"bytes"
	"cmp"
	"context"
	"flag"
	"fmt"
	"go/types"
	"io/fs"
	"os"
	"os/exec"
	"os/signal"
	"path/filepath"
	"slices"
	"strings"
	"syscall"

	"github.com/ngicks/go-codegen/codegen/pkg/imports"
	"github.com/ngicks/go-codegen/codegen/pkg/matcher"
	"github.com/ngicks/go-iterator-helper/hiter"
	"golang.org/x/tools/go/packages"
)

var (
	pkgName    = flag.String("p", "", "package name of generated file")
	outputFile = flag.String("o", "", "output file. defaults to stdout")
)

func main() {
	flag.Parse()

	ctx, cancel := signal.NotifyContext(context.Background(), syscall.SIGINT, syscall.SIGTERM)
	defer cancel()

	cmd := exec.CommandContext(ctx, "go", "env", "GOROOT")
	gorootBin, err := cmd.Output()
	if err != nil {
		panic(err)
	}

	goroot := strings.TrimSpace(string(gorootBin))
	goroot = filepath.Join(goroot, "src")

	seen := []string{}
	err = fs.WalkDir(os.DirFS(goroot), ".", func(path string, d fs.DirEntry, err error) error {
		if path == "." || err != nil {
			return err
		}
		if slices.Contains([]string{"internal", "testdata", "vendor", "cmd"}, filepath.Base(path)) {
			return fs.SkipDir
		}
		if d.IsDir() {
			seen = append(seen, path)
		}
		return nil
	})
	if err != nil {
		panic(err)
	}

	cfg := &packages.Config{
		Mode: packages.NeedName |
			packages.NeedImports |
			packages.NeedDeps |
			packages.NeedTypes |
			packages.NeedSyntax |
			packages.NeedTypesInfo |
			packages.NeedTypesSizes,
	}

	pkgs, err := packages.Load(cfg, seen...)
	if err != nil {
		panic(err)
	}

	var cloneByAssignType []imports.TargetType
	for _, pkg := range pkgs {
		cloneByAssignType = append(cloneByAssignType, slices.Collect(
			hiter.Map(
				func(obj types.Object) imports.TargetType {

					return imports.TargetType{
						ImportPath: obj.Pkg().Path(),
						Name:       obj.Name(),
					}
				},
				hiter.Filter(
					func(obj types.Object) bool {
						_, ok1 := obj.Type().(*types.Named)
						_, ok2 := obj.Type().(*types.Alias)
						return (ok1 || ok2) &&
							obj.Exported() &&
							asBasic(obj.Type()) == nil &&
							!matcher.IsNoCopy(obj.Type()) &&
							matcher.IsCloneByAssign(obj.Type(), func(n *types.Named) bool { return true })
					},
					hiter.Map(
						func(s string) types.Object {
							return pkg.Types.Scope().Lookup(s)
						},
						slices.Values(pkg.Types.Scope().Names()),
					),
				),
			),
		)...)
	}

	slices.SortFunc(cloneByAssignType, func(i, j imports.TargetType) int {
		if c := cmp.Compare(i.ImportPath, j.ImportPath); c != 0 {
			return c
		}
		return cmp.Compare(i.Name, j.Name)
	})

	buf := new(bytes.Buffer)
	fmt.Fprintf(buf, "// Code generated by github.com/ngicks/go-codegen/codegen/generator/cloner/internal/liststdtypes DO NOT EDIT.\n")
	fmt.Fprint(buf, "package "+*pkgName+"\n\n")
	fmt.Fprint(buf, "import (\n    \"github.com/ngicks/go-codegen/codegen/imports\"\n)\n\n")
	fmt.Fprintf(buf, "var stdCloneByAssign = map[imports.TargetType]struct{}{\n")
	for _, ty := range cloneByAssignType {
		fmt.Fprintf(buf, "    {ImportPath: %q, Name: %q}: {},\n", ty.ImportPath, ty.Name)
	}
	fmt.Fprintf(buf, "}\n")

	out := os.Stdout
	if *outputFile != "" {
		f, err := os.Create(*outputFile)
		if err != nil {
			panic(err)
		}
		defer func() { _ = f.Close() }()
		out = f
	}

	cmd = exec.CommandContext(ctx, "goimports")
	cmd.Stdin = buf
	cmd.Stdout = out
	err = cmd.Run()
	if err != nil {
		panic(err)
	}

	if *outputFile != "" {
		err = out.Sync()
		if err != nil {
			panic(err)
		}
	}
}

func asBasic(ty types.Type) *types.Basic {
	ty = types.Unalias(ty)
	b, ok := ty.(*types.Basic)
	if ok {
		return b
	}
	b, _ = types.Unalias(ty.Underlying()).(*types.Basic)
	return b
}
