// Code generated by github.com/ngicks/go-codegen/codegen DO NOT EDIT.
// to regenerate the code, refer to help by invoking
// go run github.com/ngicks/go-codegen/codegen cloner --help
package simple

import "maps"

//codegen:generated
func (v A) Clone() A {
	return A{
		A: v.A,
		B: v.B,
		C: func(v *int) *int {
			var out *int

			if v != nil {
				out = new(int)
			}

			inner := out
			if v != nil {
				v := *v
				vv := v
				inner = &vv
			}
			out = inner

			return out
		}(v.C),
	}
}

//codegen:generated
func (v B) Clone() B {
	return B{
		A: func(v []*[]string) []*[]string {
			var out []*[]string

			if v != nil {
				out = make([]*[]string, len(v), cap(v))
			}

			inner := out
			for k, v := range v {
				outer := &inner
				var inner *[]string
				if v != nil {
					inner = new([]string)
				}
				if v != nil {
					v := *v
					vv := func(src []string) []string {
						if src == nil {
							return nil
						}
						dst := make([]string, len(src), cap(src))
						copy(dst, src)
						return dst
					}(v)
					inner = &vv
				}
				(*outer)[k] = inner
			}
			out = inner

			return out
		}(v.A),
		B: maps.Clone(v.B),
		C: func(v []*map[int][3]string) []*map[int][3]string {
			var out []*map[int][3]string

			if v != nil {
				out = make([]*map[int][3]string, len(v), cap(v))
			}

			inner := out
			for k, v := range v {
				outer := &inner
				var inner *map[int][3]string
				if v != nil {
					inner = new(map[int][3]string)
				}
				if v != nil {
					v := *v
					outer := &inner
					var inner map[int][3]string
					if v != nil {
						inner = make(map[int][3]string, len(v))
					}
					for k, v := range v {
						inner[k] = v
					}
					(*outer) = &inner
				}
				(*outer)[k] = inner
			}
			out = inner

			return out
		}(v.C),
	}
}
