// Code generated by github.com/ngicks/go-codegen/codegen DO NOT EDIT.
// to regenerate the code, refer to help by invoking
// go run github.com/ngicks/go-codegen/codegen plain --help
package deeplynested

import (
	"github.com/ngicks/und"
	"github.com/ngicks/und/option"
)

//undgen:generated
type ImplementorPlain struct {
	Opt string `und:"required"`
}

func (v Implementor) UndPlain() ImplementorPlain {
	return ImplementorPlain{
		Opt: v.Opt.Value(),
	}
}

func (v ImplementorPlain) UndRaw() Implementor {
	return Implementor{
		Opt: option.Some(v.Opt),
	}
}

//undgen:generated
type DeeplyNestedPlain struct {
	A []map[string][5]ImplementorPlain `und:"required"`
	B [][][]map[int]Implementor
	C []map[string][5]*ImplementorPlain `und:"required"`
	D [][][]map[int]*Implementor
}

func (v DeeplyNested) UndPlain() DeeplyNestedPlain {
	return DeeplyNestedPlain{
		A: (func(v []map[string][5]und.Und[Implementor]) []map[string][5]ImplementorPlain {
			out := make([]map[string][5]ImplementorPlain, len(v))

			inner := &out
			for k, v := range v {
				outer := inner
				mid := make(map[string][5]ImplementorPlain, len(v))
				inner := &mid
				for k, v := range v {
					outer := inner
					mid := [5]ImplementorPlain{}
					inner := &mid
					for k, v := range v {
						(*inner)[k] = und.Map(
							v,
							func(v Implementor) ImplementorPlain {
								vv := v.UndPlain()
								return vv
							},
						).Value()
					}
					(*outer)[k] = *inner
				}
				(*outer)[k] = *inner
			}

			return out
		})(v.A),
		B: v.B,
		C: (func(v []map[string][5]und.Und[*Implementor]) []map[string][5]*ImplementorPlain {
			out := make([]map[string][5]*ImplementorPlain, len(v))

			inner := &out
			for k, v := range v {
				outer := inner
				mid := make(map[string][5]*ImplementorPlain, len(v))
				inner := &mid
				for k, v := range v {
					outer := inner
					mid := [5]*ImplementorPlain{}
					inner := &mid
					for k, v := range v {
						(*inner)[k] = und.Map(
							v,
							func(v *Implementor) *ImplementorPlain {
								if v == nil {
									return nil
								}
								vv := v.UndPlain()
								return &vv
							},
						).Value()
					}
					(*outer)[k] = *inner
				}
				(*outer)[k] = *inner
			}

			return out
		})(v.C),
		D: v.D,
	}
}

func (v DeeplyNestedPlain) UndRaw() DeeplyNested {
	return DeeplyNested{
		A: (func(v []map[string][5]ImplementorPlain) []map[string][5]und.Und[Implementor] {
			out := make([]map[string][5]und.Und[Implementor], len(v))

			inner := &out
			for k, v := range v {
				outer := inner
				mid := make(map[string][5]und.Und[Implementor], len(v))
				inner := &mid
				for k, v := range v {
					outer := inner
					mid := [5]und.Und[Implementor]{}
					inner := &mid
					for k, v := range v {
						(*inner)[k] = und.Map(
							und.Defined(v),
							func(v ImplementorPlain) Implementor {
								vv := v.UndRaw()
								return vv
							},
						)
					}
					(*outer)[k] = *inner
				}
				(*outer)[k] = *inner
			}

			return out
		})(v.A),
		B: v.B,
		C: (func(v []map[string][5]*ImplementorPlain) []map[string][5]und.Und[*Implementor] {
			out := make([]map[string][5]und.Und[*Implementor], len(v))

			inner := &out
			for k, v := range v {
				outer := inner
				mid := make(map[string][5]und.Und[*Implementor], len(v))
				inner := &mid
				for k, v := range v {
					outer := inner
					mid := [5]und.Und[*Implementor]{}
					inner := &mid
					for k, v := range v {
						(*inner)[k] = und.Map(
							und.Defined(v),
							func(v *ImplementorPlain) *Implementor {
								if v == nil {
									return nil
								}
								vv := v.UndRaw()
								return &vv
							},
						)
					}
					(*outer)[k] = *inner
				}
				(*outer)[k] = *inner
			}

			return out
		})(v.C),
		D: v.D,
	}
}
