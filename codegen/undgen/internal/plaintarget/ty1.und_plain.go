// Code generated by github.com/ngicks/go-codegen/codegen DO NOT EDIT.
// to regenerate the code, refer to help by invoking
// go run github.com/ngicks/go-codegen/codegen plain --help
package plaintarget

import (
	"bytes"
	"time"

	"github.com/ngicks/go-codegen/codegen/undgen/internal/targettypes/sub"
	"github.com/ngicks/und"
	"github.com/ngicks/und/conversion"
	"github.com/ngicks/und/elastic"
	"github.com/ngicks/und/option"
	"github.com/ngicks/und/sliceund"
	sliceelastic "github.com/ngicks/und/sliceund/elastic"
)

//undgen:generated
type IncludesImplementorPlain struct {
	Impl         sub.FooPlain[time.Time]
	Opt          sub.FooPlain[time.Time]               `und:"def"`
	Und          sub.FooPlain[*bytes.Buffer]           `und:"def"`
	Elastic      []option.Option[sub.FooPlain[string]] `und:"def"`
	SliceUnd     sub.FooPlain[int]                     `und:"def"`
	SliceElastic [2]option.Option[sub.FooPlain[bool]]  `und:"len==2"`
}

func (v IncludesImplementor) UndPlain() IncludesImplementorPlain {
	return IncludesImplementorPlain{
		Impl: v.Impl.UndPlain(),
		Opt: option.Map(
			v.Opt,
			func(v sub.Foo[time.Time]) sub.FooPlain[time.Time] {
				vv := v.UndPlain()
				return vv
			},
		).Value(),
		Und: und.Map(
			v.Und,
			func(v sub.Foo[*bytes.Buffer]) sub.FooPlain[*bytes.Buffer] {
				vv := v.UndPlain()
				return vv
			},
		).Value(),
		Elastic: elastic.Map(
			v.Elastic,
			func(v sub.Foo[string]) sub.FooPlain[string] {
				vv := v.UndPlain()
				return vv
			},
		).Unwrap().Value(),
		SliceUnd: sliceund.Map(
			v.SliceUnd,
			func(v sub.Foo[int]) sub.FooPlain[int] {
				vv := v.UndPlain()
				return vv
			},
		).Value(),
		SliceElastic: sliceund.Map(
			conversion.UnwrapElasticSlice(sliceelastic.Map(
				v.SliceElastic,
				func(v sub.Foo[bool]) sub.FooPlain[bool] {
					vv := v.UndPlain()
					return vv
				},
			)),
			func(o []option.Option[sub.FooPlain[bool]]) (out [2]option.Option[sub.FooPlain[bool]]) {
				copy(out[:], o)
				return out
			},
		).Value(),
	}
}

func (v IncludesImplementorPlain) UndRaw() IncludesImplementor {
	return IncludesImplementor{
		Impl: v.Impl.UndRaw(),
		Opt: option.Map(
			option.Some(v.Opt),
			func(v sub.FooPlain[time.Time]) sub.Foo[time.Time] {
				vv := v.UndRaw()
				return vv
			},
		),
		Und: und.Map(
			und.Defined(v.Und),
			func(v sub.FooPlain[*bytes.Buffer]) sub.Foo[*bytes.Buffer] {
				vv := v.UndRaw()
				return vv
			},
		),
		Elastic: elastic.Map(
			elastic.FromOptions(v.Elastic...),
			func(v sub.FooPlain[string]) sub.Foo[string] {
				vv := v.UndRaw()
				return vv
			},
		),
		SliceUnd: sliceund.Map(
			sliceund.Defined(v.SliceUnd),
			func(v sub.FooPlain[int]) sub.Foo[int] {
				vv := v.UndRaw()
				return vv
			},
		),
		SliceElastic: sliceelastic.Map(
			sliceelastic.FromUnd(sliceund.Map(
				sliceund.Defined(v.SliceElastic),
				func(s [2]option.Option[sub.FooPlain[bool]]) []option.Option[sub.FooPlain[bool]] {
					return s[:]
				},
			)),
			func(v sub.FooPlain[bool]) sub.Foo[bool] {
				vv := v.UndRaw()
				return vv
			},
		),
	}
}

//undgen:generated
type IncludesImplementorArraySliceMapPlain struct {
	A1 [3]sub.FooPlain[time.Time]
	A2 [5]sub.FooPlain[time.Time]                      `und:"def"`
	S1 []sub.FooPlain[*bytes.Buffer]                   `und:"def"`
	S2 [][]option.Option[sub.FooPlain[string]]         `und:"def,len<3"`
	M1 map[string]sub.FooPlain[int]                    `und:"def"`
	M2 map[string][2]option.Option[sub.FooPlain[bool]] `und:"len==2"`
}

func (v IncludesImplementorArraySliceMap) UndPlain() IncludesImplementorArraySliceMapPlain {
	return IncludesImplementorArraySliceMapPlain{
		A1: (func(v [3]sub.Foo[time.Time]) [3]sub.FooPlain[time.Time] {
			out := [3]sub.FooPlain[time.Time]{}

			inner := &out
			for k, v := range v {
				(*inner)[k] = v.UndPlain()
			}

			return out
		})(v.A1),
		A2: (func(v [5]option.Option[sub.Foo[time.Time]]) [5]sub.FooPlain[time.Time] {
			out := [5]sub.FooPlain[time.Time]{}

			inner := &out
			for k, v := range v {
				(*inner)[k] = option.Map(
					v,
					func(v sub.Foo[time.Time]) sub.FooPlain[time.Time] {
						vv := v.UndPlain()
						return vv
					},
				).Value()
			}

			return out
		})(v.A2),
		S1: (func(v []und.Und[sub.Foo[*bytes.Buffer]]) []sub.FooPlain[*bytes.Buffer] {
			out := make([]sub.FooPlain[*bytes.Buffer], len(v))

			inner := &out
			for k, v := range v {
				(*inner)[k] = und.Map(
					v,
					func(v sub.Foo[*bytes.Buffer]) sub.FooPlain[*bytes.Buffer] {
						vv := v.UndPlain()
						return vv
					},
				).Value()
			}

			return out
		})(v.S1),
		S2: (func(v []elastic.Elastic[sub.Foo[string]]) [][]option.Option[sub.FooPlain[string]] {
			out := make([][]option.Option[sub.FooPlain[string]], len(v))

			inner := &out
			for k, v := range v {
				(*inner)[k] = conversion.LenNAtMost(2, conversion.UnwrapElastic(elastic.Map(
					v,
					func(v sub.Foo[string]) sub.FooPlain[string] {
						vv := v.UndPlain()
						return vv
					},
				))).Value()
			}

			return out
		})(v.S2),
		M1: (func(v map[string]sliceund.Und[sub.Foo[int]]) map[string]sub.FooPlain[int] {
			out := make(map[string]sub.FooPlain[int], len(v))

			inner := &out
			for k, v := range v {
				(*inner)[k] = sliceund.Map(
					v,
					func(v sub.Foo[int]) sub.FooPlain[int] {
						vv := v.UndPlain()
						return vv
					},
				).Value()
			}

			return out
		})(v.M1),
		M2: (func(v map[string]sliceelastic.Elastic[sub.Foo[bool]]) map[string][2]option.Option[sub.FooPlain[bool]] {
			out := make(map[string][2]option.Option[sub.FooPlain[bool]], len(v))

			inner := &out
			for k, v := range v {
				(*inner)[k] = sliceund.Map(
					conversion.UnwrapElasticSlice(sliceelastic.Map(
						v,
						func(v sub.Foo[bool]) sub.FooPlain[bool] {
							vv := v.UndPlain()
							return vv
						},
					)),
					func(o []option.Option[sub.FooPlain[bool]]) (out [2]option.Option[sub.FooPlain[bool]]) {
						copy(out[:], o)
						return out
					},
				).Value()
			}

			return out
		})(v.M2),
	}
}

func (v IncludesImplementorArraySliceMapPlain) UndRaw() IncludesImplementorArraySliceMap {
	return IncludesImplementorArraySliceMap{
		A1: (func(v [3]sub.FooPlain[time.Time]) [3]sub.Foo[time.Time] {
			out := [3]sub.Foo[time.Time]{}

			inner := &out
			for k, v := range v {
				(*inner)[k] = v.UndRaw()
			}

			return out
		})(v.A1),
		A2: (func(v [5]sub.FooPlain[time.Time]) [5]option.Option[sub.Foo[time.Time]] {
			out := [5]option.Option[sub.Foo[time.Time]]{}

			inner := &out
			for k, v := range v {
				(*inner)[k] = option.Map(
					option.Some(v),
					func(v sub.FooPlain[time.Time]) sub.Foo[time.Time] {
						vv := v.UndRaw()
						return vv
					},
				)
			}

			return out
		})(v.A2),
		S1: (func(v []sub.FooPlain[*bytes.Buffer]) []und.Und[sub.Foo[*bytes.Buffer]] {
			out := make([]und.Und[sub.Foo[*bytes.Buffer]], len(v))

			inner := &out
			for k, v := range v {
				(*inner)[k] = und.Map(
					und.Defined(v),
					func(v sub.FooPlain[*bytes.Buffer]) sub.Foo[*bytes.Buffer] {
						vv := v.UndRaw()
						return vv
					},
				)
			}

			return out
		})(v.S1),
		S2: (func(v [][]option.Option[sub.FooPlain[string]]) []elastic.Elastic[sub.Foo[string]] {
			out := make([]elastic.Elastic[sub.Foo[string]], len(v))

			inner := &out
			for k, v := range v {
				(*inner)[k] = elastic.Map(
					elastic.FromUnd(und.Defined(v)),
					func(v sub.FooPlain[string]) sub.Foo[string] {
						vv := v.UndRaw()
						return vv
					},
				)
			}

			return out
		})(v.S2),
		M1: (func(v map[string]sub.FooPlain[int]) map[string]sliceund.Und[sub.Foo[int]] {
			out := make(map[string]sliceund.Und[sub.Foo[int]], len(v))

			inner := &out
			for k, v := range v {
				(*inner)[k] = sliceund.Map(
					sliceund.Defined(v),
					func(v sub.FooPlain[int]) sub.Foo[int] {
						vv := v.UndRaw()
						return vv
					},
				)
			}

			return out
		})(v.M1),
		M2: (func(v map[string][2]option.Option[sub.FooPlain[bool]]) map[string]sliceelastic.Elastic[sub.Foo[bool]] {
			out := make(map[string]sliceelastic.Elastic[sub.Foo[bool]], len(v))

			inner := &out
			for k, v := range v {
				(*inner)[k] = sliceelastic.Map(
					sliceelastic.FromUnd(sliceund.Map(
						sliceund.Defined(v),
						func(s [2]option.Option[sub.FooPlain[bool]]) []option.Option[sub.FooPlain[bool]] {
							return s[:]
						},
					)),
					func(v sub.FooPlain[bool]) sub.Foo[bool] {
						vv := v.UndRaw()
						return vv
					},
				)
			}

			return out
		})(v.M2),
	}
}

//undgen:generated
type WrappedPlain map[string][3][]sub.FooPlain[string]

func (v Wrapped) UndPlain() WrappedPlain {
	return (func(v map[string][3][]sub.Foo[string]) map[string][3][]sub.FooPlain[string] {
		out := make(map[string][3][]sub.FooPlain[string], len(v))

		inner := &out
		for k, v := range v {
			outer := inner
			mid := [3][]sub.FooPlain[string]{}
			inner := &mid
			for k, v := range v {
				outer := inner
				mid := make([]sub.FooPlain[string], len(v))
				inner := &mid
				for k, v := range v {
					(*inner)[k] = v.UndPlain()
				}
				(*outer)[k] = *inner
			}
			(*outer)[k] = *inner
		}

		return out
	})(v)
}

func (v WrappedPlain) UndRaw() Wrapped {
	return (func(v map[string][3][]sub.FooPlain[string]) map[string][3][]sub.Foo[string] {
		out := make(map[string][3][]sub.Foo[string], len(v))

		inner := &out
		for k, v := range v {
			outer := inner
			mid := [3][]sub.Foo[string]{}
			inner := &mid
			for k, v := range v {
				outer := inner
				mid := make([]sub.Foo[string], len(v))
				inner := &mid
				for k, v := range v {
					(*inner)[k] = v.UndRaw()
				}
				(*outer)[k] = *inner
			}
			(*outer)[k] = *inner
		}

		return out
	})(v)
}
